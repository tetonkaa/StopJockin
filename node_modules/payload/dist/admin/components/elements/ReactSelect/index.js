"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const core_1 = require("@dnd-kit/core");
const react_select_1 = __importDefault(require("react-select"));
const react_i18next_1 = require("react-i18next");
const sortable_1 = require("@dnd-kit/sortable");
const Chevron_1 = __importDefault(require("../../icons/Chevron"));
const getTranslation_1 = require("../../../../utilities/getTranslation");
const SingleValue_1 = require("./SingleValue");
const MultiValueLabel_1 = require("./MultiValueLabel");
const MultiValue_1 = require("./MultiValue");
const ValueContainer_1 = require("./ValueContainer");
const ClearIndicator_1 = require("./ClearIndicator");
const MultiValueRemove_1 = require("./MultiValueRemove");
const Control_1 = require("./Control");
require("./index.scss");
const SelectAdapter = (props) => {
    const { t, i18n } = (0, react_i18next_1.useTranslation)();
    const { className, showError, options, onChange, value, disabled = false, placeholder = t('general:selectValue'), isSearchable = true, isClearable = true, filterOption = undefined, isLoading, onMenuOpen, components, droppableRef, selectProps, } = props;
    const classes = [
        className,
        'react-select',
        showError && 'react-select--error',
    ].filter(Boolean).join(' ');
    return (react_1.default.createElement(react_select_1.default, { isLoading: isLoading, placeholder: (0, getTranslation_1.getTranslation)(placeholder, i18n), captureMenuScroll: true, ...props, value: value, onChange: onChange, disabled: disabled ? 'disabled' : undefined, className: classes, classNamePrefix: "rs", options: options, isSearchable: isSearchable, isClearable: isClearable, filterOption: filterOption, onMenuOpen: onMenuOpen, selectProps: {
            ...selectProps,
            droppableRef,
        }, components: {
            ValueContainer: ValueContainer_1.ValueContainer,
            SingleValue: SingleValue_1.SingleValue,
            MultiValue: MultiValue_1.MultiValue,
            MultiValueLabel: MultiValueLabel_1.MultiValueLabel,
            MultiValueRemove: MultiValueRemove_1.MultiValueRemove,
            DropdownIndicator: Chevron_1.default,
            ClearIndicator: ClearIndicator_1.ClearIndicator,
            Control: Control_1.Control,
            ...components,
        } }));
};
const SortableSelect = (props) => {
    const { onChange, value, } = props;
    const uuid = (0, react_1.useId)();
    const { setNodeRef } = (0, core_1.useDroppable)({
        id: uuid,
    });
    const onDragEnd = (0, react_1.useCallback)((event) => {
        const { active, over } = event;
        if (!active || !over)
            return;
        let sorted = value;
        if (value && Array.isArray(value)) {
            const oldIndex = value.findIndex((item) => item.value === active.id);
            const newIndex = value.findIndex((item) => item.value === over.id);
            sorted = (0, sortable_1.arrayMove)(value, oldIndex, newIndex);
        }
        onChange(sorted);
    }, [onChange, value]);
    const sensors = (0, core_1.useSensors)((0, core_1.useSensor)(core_1.PointerSensor), (0, core_1.useSensor)(core_1.KeyboardSensor, {
        coordinateGetter: sortable_1.sortableKeyboardCoordinates,
    }));
    let ids = [];
    if (value)
        ids = Array.isArray(value) ? value.map((item) => item === null || item === void 0 ? void 0 : item.value) : [value === null || value === void 0 ? void 0 : value.value]; // TODO: fix these types
    return (react_1.default.createElement(core_1.DndContext, { onDragEnd: onDragEnd, sensors: sensors, collisionDetection: core_1.closestCenter },
        react_1.default.createElement(sortable_1.SortableContext, { items: ids },
            react_1.default.createElement(SelectAdapter, { ...props, droppableRef: setNodeRef }))));
};
const ReactSelect = (props) => {
    const { isMulti, isSortable, } = props;
    if (isMulti && isSortable) {
        return (react_1.default.createElement(SortableSelect, { ...props }));
    }
    return (react_1.default.createElement(SelectAdapter, { ...props }));
};
exports.default = ReactSelect;
//# sourceMappingURL=index.js.map